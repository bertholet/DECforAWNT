\chapter{Manifolds and Meshes}

\begin{figure}[h]
\begin{center}
\includegraphics[height = 4cm]{imgs/2_1_ECVsDEC.eps}
\end{center}
\vspace{-0.5cm}
\caption{Exterior calculus is defined on manifolds, discrete exterior calculus on discrete manifolds. This chapter therefore covers manifolds and discrete manifolds.}
\end{figure}

Throughout this thesis we will always have to deal with two worlds. On one side there is the continuous world, where classical calculus and exterior calculus can be used to describe problems or physical relations. On the other side is the discrete world, where computational calculations can be done and the the smooth world is approximated.

This chapter focuses the geometric objects in these worlds. On the continuous side these are manifolds, which are the mathematical objects used to describe smooth curved spaces. Manifolds are treated in Section \ref{sec::2_Manifolds}. On the other side we have discrete manifolds, which are multiple dimensional meshes and are introduced in Section \ref{sec::2_discreteManifolds}. Having a correct  understanding of both discrete and continuous manifolds is vital to understand exterior and discrete exterior calculus.

The last section of this chapter is of a more practical nature. It can be used as a guide when implementing discrete manifolds for DEC or as a hands-on section to get the most out of reading this thesis. As application some geometric operations on meshes and discrete manifolds are described.

%So lets get started. In this chapter we will have a closer look at the basic objects we will deal with throughout this text.  We start with the description of so called ''manifolds'' which describe smooth surfaces and more generally smooth spaces embedded in higher dimensional spaces.
%In the second section we have a closer look at the meshes (and more generally Simplicial Complexes) that we use in practice in the place of manifolds. The third section explains how to implement meshes and simplicial complexes in a way that is convenient for DEC purposes. 


\begin{figure}[ht]
\begin{center}
	\begin{longtable}{|p{4cm}|p{4cm}|p{4cm}|}
		\hline
		Smooth Theory& Discrete Theory& Implementation (Notes)\\
		\hline
		Smooth Manifolds (Surfaces)
		\begin{packed_itemize}
		\item[-] Maps and Coordinates
		\item[-] Tangential Space
		\item[-] Orientations
		\item[-] Bordered Manifolds
		\end{packed_itemize}
		&
		Discrete Manifolds
		\begin{packed_itemize}
		\item[-] Simplices and Simplicial Complexes
		\item[-] Discrete Manifolds
		\item[-] Orientations
		\item[-] Border Operator, Border Matrix
		\end{packed_itemize}
		&
		Meshes
		\begin{packed_itemize}
		\item[-] Winged Edge Structure
		\item[-] General Complexes
		\item[-] Sparse Matrices
		\item[-] Simple Geometric Operations
			\begin{packed_itemize}
				\item[-] Manifold Check
				\item[-] Border Computation
			\end{packed_itemize}
		\end{packed_itemize} \\
%			Smooth Surfaces & Meshes & General Meshes\\
%			-Maps and Coordinates & & \\
%			-Tangential Space & -Simplices / Simplicial Complexes & -Winged edge / Incidence\\
%			-Orientations & -Orientations& -Simple geometric operations:\\
%			-Functions on Surfaces & -Border Operator & --Orientation\\
%			-Derivative on Surfaces & & --Iterating over Neighborhoods\\
%			& & --Wellformedness \\
%			& & --Finding Border Components\\
%			& & Notes on Sparse Matrices\\
		\hline
	\end{longtable}
	\caption{Overview of the topics of this chapter}
\end{center}
\end{figure}

\section{Manifolds}
\label{sec::2_Manifolds}
In this section we introduce smooth curved spaces, known as manifolds. Some simple two-dimensional manifolds (in short: 2-manifolds) are depicted in Figure \ref{fig::2_1_manifold}.

The following topics on manifolds need to be covered:
\begin{enumerate}
\item Describing bordered manifolds using local maps
\item Tangential spaces
\item Orientation of manifolds
\item The border operator and the orientation of borders
\item Differential structure on manifolds (derivatives of functions on manifolds)
\end{enumerate}

While no application in this thesis actually exceeds 3 dimensions, discrete exterior calculus (DEC) and exterior calculus provide tools for arbitrary dimensions, without any complications. So there is no reason to cover only two or three dimensional spaces. 
		
\subsection{Describing Manifolds}	
A two dimensional manifold is an object that locally looks like a plane and possibly has one or multiple (one dimensional) borders. Three two dimensional surfaces are given in Figure \ref{fig::2_1_manifold}.

We describe manifolds using local maps. A local map at some point on the manifold describes the manifold locally; in the case of 2-manifolds as a function of two parameters. There are two types of maps: maps that describe the manifold close to borders an maps that describe the manifold at inner points, as depicted in the Figure \ref{fig::2_1_mapping}. This is taken account of by allowing the local map to either describe the manifold using a plane or a halfplane. A 2-manifold then is an object that can be described at every point locally with a 2 dimensional map (with or without border). This makes sure that the manifold looks at every point like a plane or halfplane.


Generally a $k$-dimensional manifold $M$ lying in $\mathbb R^n$ is a geometric object that locally looks like $\mathbb R^k$ or like the halfspace $\mathbb H^k = \{x= (x_1,...,x_k) \in \mathbb R^k : x_k \geq 0\}$.  Formally this is done by guarantying that at every point on the manifold there is a 'map' linking the manifold to $\mathbb R^k$ or $\mathbb H^k$.
		
For the sake of simplicity we will assume through the whole text that all functions and mappings considered are infinitely differentiable.
		
\begin{figure}
	\begin{center}
		\includegraphics[height=4cm]{imgs/2_1_2dmanifolds.eps}
		\caption{Three simple 2-manifold; the surfaces of the sphere and the torus do not have any borders, the third surface has. The inner of the sphere and the torus would be 3-manifolds with border (their borders being their surfaces)}
		\label{fig::2_1_manifold}
	\end{center}
\end{figure}
		
\begin{definition}[Map] A $k$-dimensional map is a differentiable mapping 
\[\phi: U \subset \mathbb R^k \rightarrow \phi(U)\] 
\[\begin{pmatrix}
	u_1\\ \vdots \\ u_k
\end{pmatrix} \rightarrow \begin{pmatrix}x_1(u_1,...,u_k)\\x_2(u_1,...,u_k)\\ \vdots \\ \vdots \\ x_n(u_1,...,u_k)\end{pmatrix}\]
that is injective and whose Jakobimatrix has rank $k$ on all $U$, where $U$ is some open subset of $\mathbb R^k$ or $\mathbb H^k$ (Figure \ref{fig::2_1_mapping}).
		
\end{definition} 

A $k$-manifold then is an object where you can find local maps everywhere:

\begin{definition}[Manifold] A subset $S\subset \mathbb R^n$ is a (regular) $k$ manifold, if for each point $p \in S$ there exist an open set $V\subset \mathbb R^k$ such that there is a map $\phi: U \rightarrow  V\cap S$.
\end{definition} 

	
\begin{figure}
	\begin{center}
		\includegraphics[width=14cm]{imgs/2_1_borderedmanifold_maps.eps}
		\caption{An example of a bordered 2-manifold. Left: a local map $\phi$ at some inner point. Right: a local map at a border point. The map at the border has the additional restriction that the border of the halfspace $H^2$ is mapped to the border of the manifold.}
		\label{fig::2_1_mapping}
	\end{center}
\end{figure}

There are some important details in the definition of maps. The injectivity of the maps prevents self intersections, and the non zero Jacobi determinant makes sure that the image of a map $\phi$ does not degenerate. For example the image of a two dimensional map should not degenerate to a point or a line.

\subsubsection{Local Coordinates}

A local map $\phi: U \subset \mathbb R^k \rightarrow M$ assigns local coordinates to a manifold $M$. The values of the tuple $u=(u1_,...,u_k)\in U$ are said to be the local coordinates of the point $\phi(u)$ on the manifold, in the map $\phi$. A classic example of this is the sphere parametrized by two angles using a map like
\[\phi(a,b) = (sin(a)sin(b), sin(a)cos(b), cos(a))\]
This assigns coordinates $(a,b)$ just as longitude and latitude are used as coordinate for the world. (But note that you can not parametrize the whole sphere at once if the source domain of your map is an open set and the map has to be injective)

If you have a local map $\phi$ you can also express functions $f:M \rightarrow ?$ defined on the manifold in the local coordinates given by $\phi$. This means that you consider $f \circ \phi : U \subset \mathbb R^k \rightarrow ?$ instead of $f$, such that you can use the local coordinates $(u_1,...,u_k)$ as parameter of $f$ instead of the position on the manifold. %(Image : local coordinates..) 

%\subsubsection*{A Note on Coordinates}
%Note that there are two types of coordinates here. Lets look at a 2-Manifold. You can have the local coordinates given by and depending on the local parametrisations you chose (giving you (u,v) coordinates). Then you have the global coordinates of the surrounding space $\mathbb R^3$, assigning (x,y,z) coordinates to every point.
%
%But in the end all coordinates are just descriptive tools; the geometric object we describe is assumed to exist independently of all these parameters. The 'tricky' part then is to get independence of parametrizations when we want to describe geometric properties of our manifolds. Even to get a definition of 'differentiability' on the manifold that is independent of the selected parametrization one must be careful with the definition.
%
%In fact in later applications  we will play around with coordinates, (with surface smoothing in chapter ... the global coordinates, with conformal maps in chapter ... the local coordinates). Rather than taking coordinates as describing the manifolds we take them as something associated to the geometric object to work with them or solve for them.
%
%External calculus (introduced in chapter...) will provide tools and results that do not use parametrizations.
%

	
\subsection{Tangential Spaces}		
Manifolds have tangential spaces.
For curves calculating tangents is easy. If you have a parametrization $\alpha(t): I \subset \mathbb R \to \mathbb R^n$, then $\alpha'(t) = (x_1'(t),x_2'(t),...,x_n'(t))$ is the direction of a tangent vector to the curve at the position $\alpha(t)$. 

\begin{figure}[tb]
\begin{center}
\includegraphics[width=8cm]{imgs/2_1_tangent.eps}
\end{center}
\caption{A parametrized curve, the vector $\alpha'$ and the tangential space $T_{\alpha(t_0)}$ at $t_0$.}
\label{fig::2_1_paramCurve}
\end{figure}

		While the length of $\alpha'(t)$ at the point $\alpha(t)$ depends on the parametrization $\alpha$ (for example $\alpha(2t)$ is a different parametrization of the same curve where the length doubles) the \textbf{tangential space} $ T_{\alpha(t)}S = span(\alpha'(t)) = \{x \in \mathbb R^n: x = c \alpha'(t), c \in \mathbb R\}$ does only depend of the position $\alpha(t)$ on the curve, as depicted in Figure \ref{fig::2_1_paramCurve}. 
		
We can do the same for a $k$-dimensional manifold $M$. The tangential space $T_p M$ at a point $p$ is:

\begin{enumerate}
	\item The space that approximates the surface in the best way, locally at $p$.
	\item The space that contains the tangents of all curves on the surface that go through $p$.
	\item For a given parametrization $\phi: \mathbb R^k \to \mathbb R^n$, $\phi(u) = (\phi_1(u),...,\phi_n(u))$ the tangential plane $T_{\phi(u)}$ is given by
			\[span(\frac{\partial \phi} {\partial u_1},..., \frac{\partial \phi} {\partial u_k}) = span(\begin{pmatrix}
	\frac{\partial \phi_1} {\partial u_1} \\
	\frac{\partial \phi_2} {\partial u_1}\\
	\vdots\\
	\frac{\partial \phi_n} {\partial u_1}
\end{pmatrix},...,\begin{pmatrix}
	\frac{\partial \phi_1} {\partial u_k} \\
	\frac{\partial \phi_2} {\partial u_k}\\
	\vdots\\
	\frac{\partial \phi_n} {\partial u_k}
\end{pmatrix}),\]
as depicted in Figure \ref{fig::2_1_mapping_coords} for a 2-manifold. Here the restriction that maps have a non-zero Jacobi determinant plays a role, as it means that the partial derivatives are linearly independent.
\end{enumerate}

\begin{figure}[tb]
\begin{center}
\includegraphics[width=12cm]{imgs/2_1_mapping_coords.eps}
\end{center}
\caption{A map $\phi$ of a 2 manifold $M$ is used to determine the tangential space $T_{p}M$ at some point $p$}
\label{fig::2_1_mapping_coords}
\end{figure}

The tangential space $T_p M$ is the vector space containing all tangential vectors at a point $p$. Through the tangential space, every point on a manifold gets an associated vector space. While the vector space itself is depending solely on $p$, the choice of a basis for $T_pM$ is open. Usually  the basis vectors $\frac{\partial \phi}{\partial u_i}$  are chosen, according to some local map $\phi$. But, just as it is the case in Fig. \ref{fig::2_1_mapping_coords}, these vectors are in general not orthogonal or normalized. This is something to take care of.

One special example of a manifold is  the space $\mathbb R^k$ seen as a manifold parametrized by $\mathbb R^k$ with $\phi = id$. Then the tangential space $T_p \mathbb R^k$ at any point $p$ is again $\mathbb R^k$. But still: the vectors in one tangential space $T_p \mathbb R^k$ and the vectors of another tangential space $T_q \mathbb R^k$ can not be mixed; every point gets its own proper tangential space, not shared with any other point.
		
\subsection{Orientations}
We only want to consider a special kind of manifolds: orientable manifolds. Orienting a volume is to assign a sign to the volume you are treating. Either your volume is positive or negative. 

For a vector space you can encode orientation in the ordering of basis vectors. Two ordered bases $v_1,...v_k$ and $w_1,...,w_k$ describe the same orientation if the matrix that describes the change of bases has a positive determinant. The determinant measures the signed volume spanned by a set of vectors.

In the previous section we introduced tangential spaces and emphasized that every point gets its own proper tangential vector space. Tangential spaces of points that are very close together are very similar and it makes sense to ask them to have the same orientation.

%In the last section we introduced tangential spaces and 

We saw that parametrizations can provide bases for tangential spaces. One single parametrization induces consistent orientations to the tangential spaces of all points it hits. Therefore we say that a Manifold can be oriented if all tangential spaces can be oriented consistently.

\begin{definition}[Oriented Manifold] A manifold is orientable if there exists a set of maps $\mathcal A = \{\phi: U_\phi \to \phi(U_\phi) \subset M\}$ such that the maps describe the whole manifold and any two maps $\phi$, $\psi$ which describe a common patch $\psi(U_\psi) \cap \phi(U_\phi)$ result in the same orientations i.e. the base change matrix $C$ from the base $D\phi$ to $D\psi$ has a positive determinant
\[det(C) >0\]
A manifold is oriented if for all tangential spaces a consistent orientation has been chosen.

\end{definition}

For 2d manifolds in 3d space this is the same as asking that you can consistently chose a surface normal, as tried in Fig. \ref{fig::2_1_mobius}.

\begin{figure}[t]
\begin{center}
\includegraphics[width = 6cm]{imgs/2_1mobius.eps}
\caption{The Moebius strip, the pathological example of a non orientable manifold}
\label{fig::2_1_mobius}
\end{center}
\end{figure}

\subsection{The Border Operator}
The border operator describes a special geometric operation for manifolds. 
We denote the border of a manifold $M$ by $\delta M$ and call $\delta$ the border operator. From the definition of maps at border points follows that the border of a manifold is again a manifold, where the dimension decreases by one. And from the definitions also follows, that the border of a manifold always is a manifold without border, as it is the case with spheres or tori (again see Figure \ref{fig::2_1_manifold}); this means that for bordered manifolds
\[\delta\delta M = \emptyset.\]

A central point (considering DEC) is that an oriented manifold induces an orientation to its border. This is sketched in Figure \ref{fig::2_1_borderManifold}.  What follows is a short technical description of how the orientation on the border is defined formally. The border operator and the border orientations play a central role in external calculus and throughout this thesis. Therefore it deserves to be introduced properly.

 As the orientation of a manifold is defined by the orientation of its tangential spaces we need to take a closer look at the tangential spaces of bordered manifolds.
While nothing is special for tangential spaces at non-border points, at border points two tangential spaces are present. One is the tangential space of the manifold $T_pM$ and $k$ dimensional, the other one is the $k-1$ dimensional tangential space of the border manifold $T_p \delta M$ (see Fig. \ref{fig::2_1_borderManifold}, left) . Inducing an orientation to the border means inducing an orientation in $T_p\delta M$ using the orientation of $T_p M$. This happens by defining normals on the border.

\begin{figure}
\begin{center}
\includegraphics[width = 13cm]{imgs/2_1_borderedManifold_combined.eps}
\end{center}
\label{fig::2_1_borderManifold}
\caption{On bordered manifold two tangential spaces $T_pM$ and $T_p\delta M$  are present at border points; $N$ is the outward pointing border normal (left image). The right image depicts how the manifold oriented according to the base ($b_1$,$b_2$) of some tangential space induces an orientation to the border: $N$ and a vector following the border orientation have to build a basis oriented like $b_1,b_2$.}
\end{figure}

For any border point you can define a border normal $N$. The border normal $N$ is the vector in $T_p N$ with:
\begin{itemize}
\item $N$ is orthogonal to $T_p \delta N$
\item $N$ has length 1
\item $N$ points 'outside'
\end{itemize}
Pointing outside is defined formally using the map $h$ at the border; $Dh$ is a linear bijective map from $\mathbb R^k$ to $T_pM$, so $N$ can be pulled back to $\mathbb R^k$ and it points 'outside' if the $k$th component of $Dh^{-1} N$ is negative \note{(Image?)}.

We defined orientation by the enumeration of basis vectors. So if a basis $b_1,...,b_k$ gives the orientation of $T_pM$,
a basis $\widetilde{b_1},...,\widetilde{ b_{k-1}}$ of the tangential space of the border $T_p\delta M$ is oriented according to the manifold if prepending the normal $N$ to the basis $N,\widetilde{b_1},...,\widetilde{ b_{k-1}}$ has the same orientation as $b_1,...,b_k$. This is also shown in Fig. \ref{fig::2_1_borderManifold}.


\subsection{Functions and Derivatives on Manifolds}
\label{sec::2_derivativesOnMF}

Exterior calculus is about differentiation  and integration of functions and more general things on manifolds. In this section we explain how differentiation of mappings $f:M\to M'$ between two manifolds $M$ and $M'$ is done ON manifolds.  In our setting manifolds are more than just geometric objects; they become spaces where differentiation is possible, just as it is in $\mathbb R^n$. The manifolds get a \textbf{differential structure}.

\subsubsection{Derivatives}
Given a manifold $M$ and a function $f: M \rightarrow \mathbb R^n$, what is the derivative of $f$? We want the derivative to be something very similar to the derivative $Dh$ of a function $h: \mathbb R^k \rightarrow \mathbb R^n$. In this case $Dh$ is the linear mapping that locally approximates $h$ and can be used to give the directional derivative for a direction $v$.
\[h( p + tv) \approx h(p) + Dh \cdot tv\]
We want the same for functions $f$ on manifolds: $Df$ should be a linear mapping that maps a direction to a vector that describes the change of $f$ when going in that direction. A direction on a manifold at some position is a tangential vectors. This is important: the differential $Df$ is a mapping from the \emph{tangential spaces} to vectors, as depicted in Figure \ref{fig::3_1_manifoldDerivative}. 

We can express the idea that $Df\cdot v$ describes the change of $f$ in the direction $v$ readily by using a curve $\alpha (t)$ with a tangent $\frac{\partial \alpha(0)}{\partial t} = v$ in the wished direction $v$:
\begin{equation} Df \cdot v := \frac{\partial}{\partial t} f(\alpha(t)) \label{eq:2_1_derivativeDef}\end{equation}
As $f(\alpha(t))$ is simply a function $\mathbb R \rightarrow \mathbb R^n$ we know how to calculate the right hand side $\frac{\partial}{\partial t} f(\alpha(t))$. This is not very handy for any calculations; but we can express the derivative in the local coordinates given by a parametrization $\phi(u_1,...,u_k)$.

\begin{figure}
\begin{center}
\includegraphics[width= 12.5cm]{imgs/3_1_manifoldDerivative.eps}
\end{center}
\caption{Construction of a derivative of a real valued function $f$ defined on a manifold locally parametrized by $\phi$. $Df$ at a point $p$ is a linear mapping from the tangential space $T_p M$ to $\mathbb R$}
\label{fig::3_1_manifoldDerivative}
\end{figure}

As we have seen, a parametrization provides a base of the tangential space, namely 
\[\frac{\partial\phi}{\partial u_1},..., \frac{\partial\phi}{\partial u_k}\] 
Curves can be expressed in this map and tangential vectors can be described in this base: $\alpha(t) = \phi(u_1(t),...,u_k(t))$ and $\alpha'(t) = \frac{\partial\phi}{\partial u_1} u_1' + ... + \frac{\partial\phi}{\partial u_k} u_k'$. The function $f$ also has to be given in that map , i.e. 
\begin{eqnarray*} f(u_1,...,u_k) &=& f(\phi(u_1,...,u_k)) \\
 &=& f_1(\phi(u_1,...,u_k)),...,f_n(\phi(u_1,...,u_k)). \end{eqnarray*} 
Then 
\[Df \cdot \alpha'(t) = (\frac{\partial f}{\partial u_1},..., \frac{\partial f}{\partial u_k}) \cdot \begin{pmatrix}
	u_1' \\ \vdots \\ u_k'\end{pmatrix}\]
and $Df$ is described \emph{in the local coordinates given by $\phi$} by the $ n \times k$ matrix $(\frac{\partial f}{\partial u_1},..., \frac{\partial f}{\partial u_k})$. $(u_1',...,u_k')$ is the description of the tangential vector $v = \alpha'$ in the base $D\phi$ . 

The curve $\alpha$ was only used to construct the derivative; written without $\alpha$ the derivative $Df$ in local coordinates $\phi$ is:
\[Df \cdot v = (\frac{\partial f}{\partial u_1},..., \frac{\partial f}{\partial u_k}) \cdot \begin{pmatrix}
	v_1 \\ \vdots \\ v_k\end{pmatrix}\]
where the tangential vector $v$ is expressed in the base of the tangential space induced by $\phi$
\[v = v_1 \frac{\partial \phi}{u_1} +...+ v_k \frac{\partial \phi}{u_k}\] 
 %This situation is depicted in Figure \ref{fig::3_1_manifoldDerivative}.
\subsubsection*{Derivatives of Mappings between Manifolds}
\label{sec:derivativeBetweenMfs}
A slight generalisation is considering mappings 
\[f:M\to M'\]
going from one manifold $M$ to an other manifold $M'$, as shown in Figure \ref{fig::3_1_manifoldDerivative2}. If we look again at Equation \ref{eq:2_1_derivativeDef}, we see that, as $f(\alpha(t))$ is a curve on $M'$ and $\frac{\partial}{\partial t}f(\alpha(t))$ is a tangential vector to this curve, $Df\cdot v$ has to be a vector in the tangential space of $M'$. This means that the derivative $D_pf$ at some point $p$ is a linear mapping from the tangential space $T_pM$  to the tangential space $T_{f(p)} M'$, i.e. 
\[D_p f = T_p M \rightarrow T_{f(p)} M'.\] 

If $M$ is a $k$-manifold and $M'$ a $l$-manifold $Df$ can be expressed as a $k\times l$ matrix, described relatively to two sets of local coordinates $\phi \rightarrow M$ and $\psi \rightarrow M'$.

\begin{figure}
\begin{center}
\includegraphics[width= 13cm]{imgs/3_1_manifoldDerivative2.eps}
\end{center}
\caption{Two 2-manifolds $M$ and $M'$ with local parametrizations $\phi$ and $\psi$. $f$ is a function $f: M \rightarrow M'$. $Df$ at a point $p$ is a linear mapping from the tangential space $T_p M$ to $T_{f(p)} M'$, choosing $D\phi$ and $D \psi$ to parametrize the tangential spaces $Df$ can be represented as a $2\times 2$ matrix (relative to these bases)}
\label{fig::3_1_manifoldDerivative2}
\end{figure}



%\note{	Tangential Spaces and Differential structure. Maybe put it in next chapter; here its all about geometry, not about functions.}

\input{"Chapters/Simplical Complexes.tex"}

\newpage
\section{Implementation: Mesh and basic operations}
This is the hands-on part of this chapter. The implementation chapters provide a guideline of what you need to implement to get DEC and the later applications up and running. The components needed are described and some of the more tricky details are mentioned.

\subsection{A word on Sparse Matrices}
The point of DEC is to reformulate differential equations with sparse matrices. Therefore the implementation is somewhat centered around sparse matrices.

If you plan to implement your DEC framework you should start by looking for a sparse matrix solver. For all results in this thesis the sparse Solver from the Pardiso-Project of the University of Basel has been used as a black box solver. Unfortunately it is not free-ware but any other sparse solver will do as well.

Sparse matrices are matrices where most entries are zero. Instead of storing all $n\times m$ values of a matrix, you choose to only store the non-zero values and their indices. There are different ways to do this; the pardiso solver uses the so called Yale format.

The Yale format uses 3 vectors to describe an arbitrary $n\times m$ matrix $A$. The first vector $a$ stores all non-zero values of $A$, enumerated by row. The second vector $ja$ stores the column indices of the non-zero values, again enumerated by row. The third vector $ia$ stores for every row the index $i$, such that $a(i)$ and $ja(i)$ describe the value and the row of the first element in the row. Additionally one appends the number of values in $a$ (or $ja$) to $ia$.

For example 
\[\begin{pmatrix}
1 & 0 & 0 &3 \\
 0 & 0 & 0 &2 \\
 0 & 4&2&0
\end{pmatrix} \Rightarrow \begin{cases} a &= [1,3,2,4,2] \\ ia &= [0,2,3,5]  \\ ja &= [0,3,3,1,2]\end{cases}\]
Iterating over the values and indices of the $k$th row then amounts to
\begin{algorithmic}
\FOR{i = ia(k):ia(k+1)}
	\STATE out $\gets (k,ja(i))$   //the index pair
	\STATE out $\gets a(i)$  //of this value
\ENDFOR
\end{algorithmic}

Whatever implementation of sparse matrices you choose to use or implement, the usual basic operations need to be implemented:
\begin{itemize}
\item multiplication of matrices
\item transposing matrices
%\item iterate over the column indices and values of any row
\item adding matrices
\item inverting the elements of a matrix (replace the non zero values $a$ by $1/a$)
\item multiplication of vectors
\end{itemize}

\subsection{Implementing a Mesh for DEC}
\label{sec::2_handsOnSimplicialComplexes}
Most application in this thesis focus 2-complexes i.e. classical triangle meshes, you might not need any more general implementation so we treat general $k$ complexes separately in the next section. 

For DEC we need the complete geometric information of meshes; we explicitly keep lists of vertices, edges and faces, the full information about their incidence and border relations, as well as their assigned orientations. Edges are stored once, with an arbitrary chosen orientation.

For 2d meshes a winged edge structure is a convenient choice of representation. You could also choose to represent the mesh just by keeping lists of vertices, edges and faces plus the incidence matrices, as mentioned in the next section. \note{There might be better choices... what? References?}

\begin{figure}[tb]
\begin{center}
\includegraphics[width=8cm]{imgs/2_1_wingedEdge.eps}%	
\end{center}
\caption{The information stored on a winged structure edge}%
\label{figs::2_1_wingedEdge}%
\end{figure}

In a winged edge structure you have the following three objects:
\begin{figure}[h]
\begin{center}
\includegraphics[width = 11cm]{imgs/2_2_wingedEdge2.eps}
\caption{Impementation of a winged edge structure}
\end{center}
\end{figure}

With this information present it is easy to do things like iterating over the incident edges or faces of a vertex.

%\subsection{Implementing the Border Operator}
%\note{mention this here or include it in the border section?}


%\newpage
\subsection{Implementing k-Simplicial Complexes for DEC}

\begin{figure}%
	\begin{center}
	\includegraphics[width=10cm]{imgs/2_1_Complex.eps}%	
	\end{center}
	\caption{Implementation of a $k$ Complex; use tuple of ordered indices to characterize a simplex}%
	\label{fig::2_1_Complex}%
\end{figure}

Chances are you do not need simplicial complexes of higher dimensions other than tetrahedral meshes embedded in $\mathbb R^3$. 
	
Never the less one straight forward and for DEC suitable way to implement arbitrary $k$ complexes is to store lists of simplices and represent the incidence information explicitly as sparse matrices. The incidence matrices (border operator matrices) play a central role in DEC and need to be set up anyway.

An implementation of a $k$-complex then might look like this: the vertices (0-Simplices) are stored in a list and contain their positions. A single $j$-Simplex is then represented by a $j$ tuple of vertex indices. A $k$ complex consists then of $k+1$ simplex lists; for every dimension one list, as sketched in Figure \ref{fig::2_1_Complex}.

Setting up the border operator matrices $\delta_j$ for complexes of arbitrary dimensions is not completely trivial, as to compute relative orientations of simplices you need to find the sign of some permutation. It gets much easier if the index tuples describing the simplices are sorted i.e.
\[(i_1,i_2,...,i_j): i_1 < i_2 <...<i_j.\] 
With sorted indices we can directly use the definition of the border operator from Section \ref{sec::2_borderOrientation} to compute the relative orientation of a $j-1$ simplex $(v_0,...,\widehat{v_l},..., v_{j-1})$ lying on the border of a $j$ simplex $(v_0,...,\widehat{v_l},..., v_{j})$:
\[Orientation = (-1)^l\]

But while it is easier to compute relative orientations if the indices of your simplices are sorted, you loose the ability to store arbitrary simplex orientations using the ordering of vertices. For all but the $k$ simplices this does not matter, even for oriented discrete $k$-manifolds, as there is nor 'right' or 'wrong' orientation and all that matters is that you consistently use the same orientation all the time. But for the $k$ simplices in an oriented $k$ manifold you really need to be able to chose the orientation, so you have to keep track of the orientation independently in an additional variable (as is done in Figure \ref{fig::2_1_Complex}).

So when you resort the tuple of a $k$-simplex in a $k$-manifold you need to determine if an index tuple describes the same orientation as the sorted index tuple. This can be done using a so called inversion table. Lets say the tuple $(1,2...,n)$ is scramble to the tuple $(i_1,...,i_n)$. An inversion is then an index pair $(i_l,i_k)$, where $l<k$ but $i_l >i_k$, i.e. the order of $i_l,i_k$ was inverted. The number of inversions of a single index is then the number of indices left to it that are greater than the index. The relative orientation of a simplex represented by a scrambled tuple to a simplex with the sorted tuple is $(-1)^{\#inversions}$ where $\#inversions$ is the total number of inversions.

Example: 
\begin{eqnarray*}
3,2,5,4,1 \\
0,1,0,1,4
\end{eqnarray*}
The first line represents the permuted indices the lower the number of inversions of every index. The total number of inversion is 6 and the relative orientation of
$\{3,2,5,4,1\}$ to $\{1,2,3,4,5\}$ is $(-1)^6 = 1$ which would meant that both tuples represent simplices with the same orientation.

Setting up a $k$ complex  and all the border matrices $\delta_j$ might then look like this: start with the $k$ simplices; resort their indices if needed and adapt the stored orientation.
Then enumerate all occuring $k-1$ simplices (sort their indices, you do not need to adapt the orientation) and set up the border matrix $\delta_k$. Proceed with enumerating all $k-2$ simplices occuring as borders of $k-1$ simplices and the set up of the $\delta_{k-1}$ matrix and so on.

		
\subsection{Implementing Basic Mesh Operations}
To get later applications working you will need most of the following tools. For the applications presented in this thesis they do not need to perform extremely fast, as these operations will occur only once when setting up an application.

\subsubsection{Setup a DEC mesh from a Wireframe Mesh Representation}
The usual representation of meshes as e.g. with .obj files is by just giving a list of vertex positions and a list of faces; you need to set up the winged edge structure or $k$ complex from these.
	
\subsubsection{Set Up Border Matrices}
If you chose a winged edge structure to implement 2-complexes, you additionally need to set up the border matrices $\delta_2$ and $\delta_1$. Store them directly with your mesh. These matrices play a central role in DEC; you could say that this whole thesis is about these matrices, so test them well. If you have an oriented discrete manifold, you can also use the relation $\delta_{k}\cdot \delta_{k+1} = 0$ (the border of the border of an oriented manifold is empty) to check their correctness. Implementing the other tools in this section will test these matrices further.

\subsubsection{Check if a DEC Mesh is a Discrete Manifold}
\begin{figure}[tb]
	\begin{center}
	\includegraphics[width=12cm]{imgs/2_3_danglingTeapot.eps}
	\end{center}
	\caption{A teapot mesh that on the first look seems to be a discrete borderless 2 manifold but turns out to be a mesh with border and dangling triangles, which makes it a non-manifold mesh and therefore not suited for some DEC applications}
\end{figure}

To avoid singular matrices and to eliminate the possibility that bugs occur due to the ill-formedness of a $k$-complex or mesh (as in Fig. \ref{fig::2_2_dangling} and \ref{fig::2_2_borderUnoriented}) it is handy to have such a test method. I.e. you should test for orientation errors and the connectedness to avoid dangling simplices.
The orientation needs to be checked for $k$ simplices only, which would be for example the faces for a 2D-mesh. 

That a $k$-complex is oriented can be checked by looking at $\delta_k$. Any column has to have either exactly one entry or two entries that sum up to zero. This checks exactly the condition we gave in \ref{sec::2_orientedDiscreteMF}: Any 1 simplex is either on the border (therefore being part of exactly one $k$ simplex) or between 2 $k$-simplices, having once positive and once negative orientation.

If you are sticking with the winged edge mesh, finding dangling faces is fairly simple; at every vertex iterate over all edges and make sure that exactly 2 or no edges have only one neighbour face.
\begin{figure}
	\begin{center}
	\includegraphics[width=7cm]{imgs/2_3_danglingTriangles.eps}
	\vspace{0.5cm}
	
	\includegraphics[width=10cm]{imgs/2_3_DanglingTetrahedra.eps}
	\end{center}
	\caption{Top: On the left all 2-simplices (triangles) can be reached indirectly by hopping from triangle to triangle where every hopping pair shares a 1-simpex (considering only triangles that neighbour the marked vertex). On the right the manifold property is violated. Bottom: two 3-simplices that share a common face (no dangling), that share an edge (dangling) and that share a vertex (dangling)}
	\label{fig::2_3_dangling}
\end{figure}
Detecting dangling $k$-simplices in a $k$-complex needs slightly more work. Formally dangling was prevented by asking that at any vertex, the incident $k$-simplices form either a ball or a half ball. This is equivalent to asking that any two $k$ simplices neighbouring some vertex $v_0$ are connected via $k$ simplices neighbouring $v_0$ that share $k-1$ faces, as depicted in Figure \ref{fig::2_3_dangling}.  So to check wellformedness at a vertex, take all neighbour $k$-simplices, choose one and put it on a stack. Pop the stack and push all $k$-simplices that share a $k-1$ face with the popped simplex. Keep on popping and pushing like this. If any $k$ simplex remains you have a dangling situation. \note{(Clear enough?)}
	
	
Note that these non-manifold detection algorithms will not detect non-manifoldness due to self intersections (like the most right situation in Fig. \ref{fig::2_2_dangling}), as such problems do not show in the incidence matrices. But for most applications it is enough that we have well-formed incidence matrices and do not care if such self intersections occur.
	
\subsubsection{Find Borders}
Given an oriented discrete $k$-manifold: find the $(k-1)$-complex that represents its border. Finding the border can be easily done by applying the border Operator $\delta_k$ to the $(1,1,1,1,1...)$ vector. The resulting vector then exactly represents the border manifold. This also tests the correctness of your border matrix and the correctness of the orientation of your discrete $k$-manifold.
	
\subsubsection{Get Connected Components of a set of K-Simplices}
It also comes in handy to be able to identify the different connected components of a mesh, as the different components a mesh often need to be treated independently from each other as separate objects.
	
Given a list of $k$-simplices which forms one or more discrete manifolds you should identify the different connected components. You can also apply this
to the border of a $k$ manifold with multiple borders to get the various border components as in Figure \ref{fig::2_3_bunnyBorder}.
	
\begin{figure}[t]
	\begin{center}
	\includegraphics[width=7cm]{imgs/2_3_bunny_borders.eps}
	\end{center}
	\caption{A mesh with multiple border components.}
	\label{fig::2_3_bunnyBorder}
\end{figure}

